"""Implements the Role Play and a Bot object

"""
import os

import pickle
import asyncio
import collections
from transformers import pipeline
import random
import enum
import inference_server
import prompts
import datetime
from typing import Union, List

class GameState(enum.Enum):
    WAITING=0
    PROMPT=1
    CONVO=2
    JUDGE=3
    FINISHED=4

def chunks(lst, n):
  """Yield successive n-sized chunks from lst."""
  for i in range(0, len(lst), n):
    yield lst[i:i + n]


def get_player_id(message):
  return str(message.channel.id) + '-' + str(message.author.id)

def sample_autogenerated_prompt():
  return random.choice(prompts.AUTO_GENERATED_V0)

GAME_START="""
Welcome to Clueless! Type `!help` at any time to get
a refresher of game rules.
"""

GAME_RULES="""
Clueless a three-round game for an even number of players.

Round 1:
  You come up with prompts for two players to talk about.

Round 2:
  You and a randomly chosen partner are assigned a prompt and roles for a role-play conversation. However, one person among all pairs is the "Clueless" one, and does not see the prompt! If you are that player, try to pretend you know what's going on!

Round 3: 
  Everyone sees everyone else's conversation and votes on which player is most likely to be Clueless. If you are the clueless player, you get 100 points if you evade detection. If you are not the clueless player, you get 100 points for guessing right. The player with the fewest votes also gets 100 points, so try to act natural!

COMMANDS
`!play [ROOM CODE]` - join a room. If no room code is provided, you are
  added to a randomly chosen room.

`!start` - start the game with your room.

`!help` - prints this message
"""

PROMPT_HEADER="""
PROMPT PHASE STARTED

Type a short role-playing story for two players, (A) and (B). 
Your story must refer to `(A)` and `(B)` explicitly. Alternatively,
you can copy-paste the following auto-generated prompt: 
"""
CONVO_HEADER = """
CONVERSATION PHASE STARTED
Your Prompt: {}
Your Role: {} 
Send some text to begin the conversation! All convos end in {} minutes.
"""

JUDGING_HEADER="""
JUDGING PHASE STARTED, THERE ARE {} CONVERSATIONS AND 1 CLUELESS
"""

class Player(object):
  # Represents a real human playing on a discord channel.
  def __init__(self, channel, bot=False):
    self.channel = channel
    self.score = 0
    self.bot = bot
    self.reset()
  def reset(self):
    self.convo = None # Reference to shared conversation object
    self.role = None
    self.choice = None
    self.prompt=None
    self.bot_vote = 0 # how many ppl accuse of being bot.
    self.clueless=False # for playing the clueless game


class RolePlayGame(object):

  def __init__(self, log_dir='logs', convo_timeout=180, nobot_mode=False):
    """
    Args:
      log_dir: Path to save conversation logs and scores to.
      convo_timeout: how long the conversation round lasts.
      nobot_mode: If True, plays Clueless instead of Roleplay-and-a-Bot. 
        This is for bootstrapping data collection.
    """
    self.log_dir = log_dir
    self.convo_timeout=convo_timeout
    self.players = {}
    self.state = GameState.WAITING
    self.convos = []
    self.nobot_mode = nobot_mode

  # ------ UTILITY FUNCTIONS --------

  @property
  def num_players(self):
    return len(self.players)

  @property
  def num_prompts(self):
    # Counts how many prompts are in play.
    total = 0
    for p in self.players.values():
      if p.prompt is not None:
        total += 1
    return total

  @property
  def prompts(self):
    return [p.prompt for p in self.players.values()]

  @property
  def num_judged(self):
    count = 0
    for p in self.players.values():
      if p.choice != None:
        count += 1
    return count
  
  async def add_player(self, message):
    self.players[get_player_id(message)] = Player(message.channel) 
    # send welcome message to player
    asyncio.create_task(message.channel.send(GAME_START))
    # Broadcast to all players 
    await self.broadcast("Player %d joined." % self.num_players)

  def get_player(self, message):
    return self.players[get_player_id(message)]

  async def broadcast(self, text: Union[str, List[str]]):
    """Send a message to all players concurrently."""
    # TODO - discord client has loop, potentially share with RolePlayGame
    tasks = []
    if isinstance(text, str):
      texts = [text]*self.num_players
    else:
      texts = text
    for p, t in zip(self.players.values(), texts):
      tasks.append(asyncio.create_task(p.channel.send(t)))
    await asyncio.wait(tasks)

  # ----- ENTRY POINT ---------
  async def handle_message(self, message):
    """Handle message coming from one of the players.""" 

    if self.state == GameState.WAITING:
      await self.handle_waiting(message)
    elif self.state == GameState.PROMPT:
      await self.handle_prompt(message)
    elif self.state == GameState.CONVO:
      self.handle_convo(message)
    elif self.state == GameState.JUDGE:
      await self.handle_judge(message)



  # ------ WAITING PHASE -------
  async def validate_start(self, message):
    if self.nobot_mode:
      # Playing Clueless
      if self.num_players % 2 == 0 and self.num_players > 2:
        await self.start_game()
    else:
      if self.num_players <= 2:
        asyncio.create_task(message.reply("There are currently %d players, need 3 or more players to start." % self.num_players))
      else:
        await self.start_game()

  async def handle_waiting(self, message):
    if message.content == "!start":
      await self.validate_start(message)

  async def start_game(self):
    """Starts the game."""
    self.state = GameState.PROMPT
    texts = []
    for p in self.players.values():
      # Reset state for players
      p.reset()
      texts.append(PROMPT_HEADER + "\n{}".format(sample_autogenerated_prompt()))
    await self.broadcast(texts)

  # ------ PROMPT PHASE --------
  async def validate_prompt(self, message):  
    is_valid = "(A)" in message.content and "(B)" in message.content
    if not is_valid:
      asyncio.create_task(message.reply("Prompt needs to contain the string `(A)` and `(B)` referring to two players. Enter the prompt again."))
    else:
      # store the message
      p = self.get_player(message)
      p.prompt = message.content
      await message.reply("Prompt accepted. Please wait for other players to submit their prompts.")

  async def handle_prompt(self, message):
    # user is supplying their narrative prompt
    await self.validate_prompt(message)
    if self.num_prompts == self.num_players:
      await self.start_conversation_phase()

  # ------ CONVO PHASE --------
  async def start_conversation_phase(self):
    # Pair up players and start conversations between them.
    # odd number of players - one bot. even number of players, two bots.
    prompts = [p.prompt for p in self.players.values()]
    random.shuffle(prompts)

    players = list(self.players.values())
    print('starting convo phase with %d players' % len(players))
    if self.nobot_mode:
      # requires even number of players
      self.num_bots = 0
    else:
      self.num_bots = 2 if len(self.players) % 2 == 0 else 1
    random.shuffle(players)
    # first N players are paired up with bots. Bots are inserted
    # before or after the player's position, so that they are paired
    # up randomly as (A) or (B).
    
    for b in range(self.num_bots):
      bot = Player(channel=None, bot=True)
      players.insert(random.choice((b*2, b*2+1)), bot)

    if self.nobot_mode:
      # randomly chosen player is the Clueless one
      players[0].clueless = True

    # Pair up the remaining players who are talking to each other
    for i, (p1, p2) in enumerate(chunks(players, 2)):
      convo = inference_server.Conversation(prompt=prompts[i])
      self.convos.append(convo)
      for p, r in zip([p1, p2], ['A', 'B']):
        convo.add_player(p, r)

    # Message all players with prompt and their assigned roles (A) or (B) 
    await self.broadcast_roles()
    # after we have broadcasted all roles, we start convo countdown.
    self.bg_task = asyncio.create_task(self.convo_countdown())
    
    self.state = GameState.CONVO
    # For each convo, maybe the bot starts the conversation.
    for convo in self.convos:
      if convo.bot_role:
        asyncio.create_task(convo.maybe_bot_initiate())
 
  async def broadcast_roles(self):
    texts = []
    for p in self.players.values():
      if p.clueless:
        tokens = p.convo.prompt.split(" ")
        random.shuffle(tokens)
        scrambled_prompt = " ".join(tokens[:5]) 
        # To make things easier, maybe we can show 5 randomly chosen words
        clueless_prompt = "YOU ARE CLUELESS - try to figure out what is going on from these clue words {}".format(tokens[:5])
        texts.append(CONVO_HEADER.format(
            clueless_prompt, p.role, self.convo_timeout//60))
      else:
        texts.append(CONVO_HEADER.format(p.convo.prompt, p.role, self.convo_timeout//60))
    await self.broadcast(texts)

  def handle_convo(self, message):
    # Creates background task to dispatch convo to relevant players.
    # Delgate to the convo.
    p = self.get_player(message)
    # We don't await this background task, because we want to be able to
    # concurrent conversations.
    asyncio.create_task(p.convo.handle_convo(p.role, message.content))

  async def convo_countdown(self):
    await asyncio.sleep(self.convo_timeout)
    # Switch to JUDGE phase
    self.state = GameState.JUDGE
    # assign number to each player and re-render convo

    if self.nobot_mode:
      text = JUDGING_HEADER.format(len(self.convos))
    else:
      text = ("JUDGING PHASE STARTED\nTHERE ARE {} CONVERSATIONS AND {} BOTS.\n"
    "REPLY WITH THE PLAYER NUMBER THAT YOU THINK IS MOST LIKELY A BOT\n".format(len(self.convos), self.num_bots))
    # Rename (A) and (B) across all convos into unique player
    # names. we need to recover this later.
    self.new_role_to_player = {}
    # store new role integers for bot or clueless players
    self.bot_new_roles = []
    new_role = 1
    # Randomize order of convos, otherwise the first one always has the bot.
    random.shuffle(self.convos)
    for convo in self.convos:
      text += "-"*10 + "\n"
      old_role_to_new_role = {}
      for old_role, player in convo.role_to_player.items():
        old_role_to_new_role[old_role] = new_role
        self.new_role_to_player[new_role] = player
        # We need this later to figure out who guessed right.
        if player.bot or player.clueless:
          self.bot_new_roles.append(new_role)
        new_role += 1
      for old_role, t, _ in convo.chat_history:
        text += "{}: {}\n".format(old_role_to_new_role[old_role], t)
    await self.broadcast(text)


  # ------ JUDGING PHASE --------
  async def validate_judge(self, message):
    valid_responses = [str(i) for i in self.new_role_to_player.keys()]
    if message.content not in valid_responses:
      await message.reply(
              "Invalid selection {}. Please reply with one of {}".format(message.content,  valid_responses))
    else:
      new_role =int(message.content)
      p = self.get_player(message)
      p.choice = new_role
      # Increment counter on the accused player so we can save later.

      p2 = self.new_role_to_player[new_role]
      p2.bot_vote += 1

      await message.reply("Done. Please wait for other players to guess. Until the last player responds, you can change your answer by re-sending your guess.")

  async def handle_judge(self, message): 
    # parse the accusation.
    await self.validate_judge(message)
    if self.num_judged == self.num_players:
      print('broadcasting scores...')
      await self.broadcast_scores()
      await self.cleanup()

  async def compute_scores(self):
    max_bot_vote = max([p.bot_vote for p in self.players.values()])
    for p in self.players.values():
      # Find the matching new role identifier
      if not p.clueless and p.choice in self.bot_new_roles:
        p.score += 100
      if p.clueless and p.bot_vote < max_bot_vote:
        p.score += 100
    # new role int whose player has lowest bot_vote
    most_human_role = min(self.new_role_to_player, 
            key=lambda u: self.new_role_to_player[u].bot_vote)
    self.new_role_to_player[most_human_role].score += 100
    return most_human_role

  async def broadcast_scores(self):
    # Broadcasts results of the game.
    # Compute scores
    most_human_role = await self.compute_scores()
    # Broadcast scores
    texts = []
    for p in self.players.values():
      if self.nobot_mode:
        text = "RESULTS\nCLUELESS: {}\n\nSCORES\n".format(self.bot_new_roles)
      else:
        text = "RESULTS\nBOTS: {}\n\nSCORES\n".format(self.bot_new_roles)
      text += "VOTED MOST HUMAN: {}\n".format(most_human_role)
      # Assemble the text printout for this player
      for new_role, p2 in self.new_role_to_player.items():
        if p2.bot:
          continue
        marker = " (You)" if p2 == p else ""
        text += "Player {}{} (guessed {}): {}\n".format(
                new_role, marker, p2.choice, p2.score)
      text += "To play again with the current room, type `!start`"
      texts.append(text)
    await self.broadcast(texts)
  
  # -- CLEANUP PHASE ----

  async def cleanup(self):
    # Saves logs to disk, clear state variables so players can play again
    self.convos = []
    # Save the prompts and conversations to disk, asynchronously
    asyncio.create_task(self.save())
    self.state = GameState.WAITING

  async def save(self):
    # Save several streams.
    session_dt = datetime.datetime.now()
    session_string = session_dt.strftime('%Y-%m-%d_%H_%M_%S')
    # Save player data
    # Map their new_role choice to relevant convo role
    player_data = [(p.prompt, p.role, p.choice, p.score, p.bot_vote, p.clueless) for p in self.players.values()]
    with open(os.path.join(self.log_dir, 'players-%s.p' % session_string), 'wb') as f:
      pickle.dump(player_data, f)
    # Save conversation stream

    # Count bot accusations per playe
    convos = []
    for c in self.convos:
      role_to_player_data = {}
      for r, p in c.role_to_players.items():
        role_to_player_data[r] = (p.prompt, p.role, p.choice, p.score, p.bot_vote, p.clueless)
        convos.append((c.prompt, c.chat_history, c.bot_role, c.model_id, 
            role_to_player_data))
    with open(os.path.join(self.log_dir, 'convos-%s.p' % session_string), 'wb') as f:
      pickle.dump(convos, f)
    print('saved session data %s' % session_string)

